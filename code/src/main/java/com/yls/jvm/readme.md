## jvm与程序的生命周期
>  2019/11/5   **yls**

### java虚拟机结束生命周期的情况：
1. 执行了System.exit();
2. 程序正常运行结束
3. 程序在执行过程中遇到异常或错误而异常终止
4. 由于操作系统出现错误而导致jvm进程终止（不可人为控制）
### 类的加载，连接（验证，准备，解析），初始化，使用，卸载
1. 加载:jvm通过类加载器查找并加载类的二进制数据，将类的.class文件中的二进制数据读入到内存，将其放在运行时的数据区的方法区中，然后在内存中创建一个java.lang.Class对象用来来封装类在方法区中的数据结构
   1. .class加载方式
      1. 从本地系统中加载
      2. 网络下载.class文件
      3. 从zip,jar中加载
      4. 将java源文件动态编译为.class文件
   2. 查看是否被加载,打印加载类的信息
      1. 在vm options中输入 `-XX:+TraceClassLoading`
      ```$xslt
      -XX:+<option>  表示开启option选项
      -XX:-<option>  表示关闭option选项
      -XX:<option>=<value> 表示将option的值设置为value
      ```
2. 连接：
   1. 验证：确保被加载的类的正确性(验证内容：1.类文件的结构检查，2.语义检查，3.字节码验证，4.二进制兼容性的验证)  
   2. 准备：为类的静态变量分配内存，并将其初始化为默认值
   3. 解析：把类中的符号引用转换为直接引用，在类型的常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程
3. 初始化：为类的静态   **变量**   赋予正确的初始值
    1. 类的初始化时机：
       1. java虚拟机初始化一个类时，要求它的父类必须被初始化，但这条接口并不适合接口
       2. 初始化一个类时，并不会先初始化他的接口
       3. 初始化一个接口时，并不会先初始化他的父接口
       4. 只有当程序首次使用接口的常量时，才初始化接口
    >  注意：
    >  1. (静态常量(例如：public static final int b=1;)在编译时就被存到调用该常量的方法的的类的常量池中，所以使用该常量不会导致定义该常量的类的初始化；
    >     当一个常量的值并非编译器可以确定地（例如：public static final String s= UUID.randomUUID().toString()），那么其值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类初始化)
    >  2. (使用子类调用父类的静态变量不会导致该子类的初始化,由于使用的是父类中的静态变量，所以不会初始化子类,只有直接调用了该静态字段的类才会被初始化)
4. java程序对类的使用可分为主动使用和被动使用，只有在每个类或接口被java程序“首次主动使用时”才 *初始化* 他们：
   1. 主动使用（7种）
      1. 创建类的实例（注意：引用数组`Grandpa[] grandpas=new Grandpa[1];`不是主动使用，不会导致类的初始化 ）
      2. 访问类或接口的静态变量，或者为静态变量赋值
      3. 调用类的静态方法
      4. 反射（如Class.forName(***)）
      5. 初始化类的子类
      6. jvm启动时被标记为启动的类
      7. 动态语言的支持（了解即可）
   2. 除了以上情况，都是被动使用，不会导致类的初始化
5. 类实例化
   1. 为新的对象分配内存
   2. 为实例变量设置默认值
   3. 为实例变量赋予正确的初始值
   4. java编译器为类中每一个构造函数都生成一个初始化方法，在java的.class文件中，这个实例初始化方法被称为“<init>”
6. 类的卸载
   1. 一个类何时结束生命周期，取决于他的Class对象何时结束生命周期，当一个类的Class对象不在引用，即不可触及时就会结束
   
   
   
   
   
### 类加载器种类及关系
1. 根类加载器:没有父加载器
2. 扩展类加载器：父加载器是根加载器
3. 系统类加载器：父加载器是扩展加载器
4. 用户自定义类加载器：父加载器是系统加载器

#### 类加载器双亲委托机制
   1. 加载器加载.class文件时，先自底向上委托给父加载器加载，若父加载器加载失败，则返回
   2. 好处：
      1. 可以确保java核心库的类型安全所有java应用都会引用java.lang.Object类，所以这个类会被加载到java虚拟机中；如果这个加载过程是由java应用自己的加载类完成，很可能会加载多个不仅阿荣的Object类
      借助双亲委托机制，java核心库的加载工作都是由启动类加载类同意完成，确保只有一个版本
      2. 可以确保java核心库所提供的类不会被自定义的类所替代
      3. 不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以共存在jvm中，只需要用不同的类加载器加载即可。不同类加载的类之间是不兼容的，相当于在jvm内部创建了一个又一个相互隔离的java类空间
   
   